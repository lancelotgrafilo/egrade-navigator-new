const express = require('express');
const asyncHandler = require('express-async-handler');
const facultyStaffModel = require('../models/facultyStaffModel');
const Joi = require('joi');
const bcrypt = require('bcryptjs');
const csv = require('csv-parser');
const fs = require("fs");
const path = require('path');  // Import the path module
const multer = require('multer');
const mongoose = require('mongoose');
mongoose.set('debug', true);

const { sendEmailSuccess } = require('./emailSuccessController');
const { getConfirmationCode } = require('../utils/confirmationStore');

// Function to generate a random password
const generateRandomPassword = (length = 12) => {
  const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let password = '';
  for (let i = 0; i < length; i++) {
    const randomIndex = Math.floor(Math.random() * charset.length);
    password += charset[randomIndex];
  }
  return password;
};


const facultyStaffSchema = Joi.object({
  ID: Joi.string().default("fs-001"),
  facultyID: Joi.string().required(),
  last_name: Joi.string().required(),
  first_name: Joi.string().required(),
  middle_name: Joi.string().required(),
  specialization: Joi.string().required(),
  contact_number: Joi.string().required(), 
  email: Joi.string().email({ tlds: { allow: false } }).required(),
  subjects: Joi.array().items(Joi.any()).default([]), // Default value added
  isActive: Joi.boolean().default(true), // Default value added
  createdAt: Joi.date().default(Date.now), // Default value added
});

const validateFacultyStaff = (data) => {
  return facultyStaffSchema.validate(data, { abortEarly: false }); // Ensure all errors are captured
};

// @desc    Post Faculty Staffs
// @route   GET /api/fetch_faculty_staffs
// @access  Private
const postFacultyStaff = asyncHandler(async (req, res) => {
  // Validate and apply default values
  const { error, value: validatedData } = validateFacultyStaff(req.body);

  if (error) {
    console.log("Validation Error:", error.details); // Debugging line
    return res.status(400).json({ message: error.details[0].message });
  }

  const { ID, facultyID, last_name, first_name, middle_name, specialization, contact_number, password, email, isActive, createdAt } = validatedData;
  
  const generatedPassword = generateRandomPassword();
  const hashedPassword = await bcrypt.hash(generatedPassword, 10); // 10 is the salt rounds

  const facultyStaff = new facultyStaffModel({
    ID,
    facultyID,
    last_name,
    first_name,
    middle_name,
    specialization,
    contact_number,
    password: hashedPassword, 
    email,
    isActive,
    createdAt,
  });


  try{
    await facultyStaff.save();

    // Retrieve the confirmation code
    const confirmationCode = getConfirmationCode(email); // Ensure to pass the email to get the code
    // console.log("adminController: confirmation Code: ", confirmationCode);

    // Call sendEmailSuccess with the required information
    await sendEmailSuccess({
      email,
      generatedPassword,
      confirmationCode 
    });

    console.log("New Faculty Staff Saved:", facultyStaff);
    res.status(201).json({ message: "New Faculty Staff Successfully Added" });

  } catch (err) {
    console.error('Error saving Faculty Staff:', err);
    res.status(500).json({ message: "Failed to add faculty Staff", error: err });
  }
   
  
});

// @desc    Get Faculty Staffs
// @route   GET /api/fetch_faculty_staffs
// @access  Private
const getFacultyStaff = asyncHandler ( async (req, res) => {
  const { search } = req.query;

  try {
    // Fetch the updated list
    const allFacultyStaffs = await facultyStaffModel.find().exec();
    const allFacultyStaffWithIndex = allFacultyStaffs.map((facultyStaff, index) => ({
      ...facultyStaff.toObject(),
      originalFacultyStaff: index + 1
    }));

    if(allFacultyStaffWithIndex.length === 0){
      const allFacultyStaffs = await facultyStaffModel.find().exec();
      allFacultyStaffWithIndex = allFacultyStaffs.map((facultyStaff, index) => ({
        ...facultyStaff.toObject(),
        originalFacultyStaff: index + 1
      }))
    };

    

    let filteredFacultyStaff = allFacultyStaffWithIndex;

    if(search){
      const lowercasedSearch = search.toLowerCase().trim();
      filteredFacultyStaff = allFacultyStaffWithIndex.filter(facultyStaff => 
        [
          facultyStaff.facultyID,
          facultyStaff.last_name,
          facultyStaff.first_name,
          facultyStaff.middle_name,
          facultyStaff.specialization,
          facultyStaff.contact_number
        ].some(field => 
          field.toLowerCase().includes(lowercasedSearch)
        )
      )
    }

    res.status(200).json(filteredFacultyStaff);
  } catch (error) {
    console.log("Failed Fetching Faculty Staff", error);
    res.statu(500).json({
      message: "Failed Fetching Faculty Staffs",
      error: error.message
    });
  }
});

// @desc    Get Faculty Staffs
// @route   GET /api/get_faculty_to_class_prog
// @access  Private
const getFacultyToClassProg = asyncHandler ( async (req, res) => {
  const { search } = req.query;

  try {
    // Fetch the updated list
    const allFacultyStaffs = await facultyStaffModel.find().exec();
    const allFacultyStaffWithIndex = allFacultyStaffs.map((facultyStaff, index) => ({
      ...facultyStaff.toObject(),
      originalFacultyStaff: index + 1
    }));

    if(allFacultyStaffWithIndex.length === 0){
      const allFacultyStaffs = await facultyStaffModel.find().exec();
      allFacultyStaffWithIndex = allFacultyStaffs.map((facultyStaff, index) => ({
        ...facultyStaff.toObject(),
        originalFacultyStaff: index + 1
      }))
    };

    let filteredFacultyStaff = allFacultyStaffWithIndex;

    if(search){
      const lowercasedSearch = search.toLowerCase().trim();
      filteredFacultyStaff = allFacultyStaffWithIndex.filter(facultyStaff => 
        [
          facultyStaff.facultyID,
          facultyStaff.last_name,
          facultyStaff.first_name,
          facultyStaff.middle_name,
        ].some(field => 
          field.toLowerCase().includes(lowercasedSearch)
        )
      )
    }

    res.status(200).json(filteredFacultyStaff);
  } catch (error) {
    console.log("Failed Fetching Faculty Staff", error);
    res.status(500).json({
      message: "Failed Fetching Faculty Staffs",
      error: error.message
    });
  }
});

// @desc    Get Instructor by ID with search functionality for students
// @route   GET /api/get_instructors_load/:id
// @access  Private
const getInstructorById = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { search } = req.query;

  try {
    // Fetch the instructor by ID
    const instructor = await facultyStaffModel.findById(id);

    if (!instructor) {
      return res.status(404).json({ message: 'Faculty Staff not found' });
    }

    // Convert to plain object for easier manipulation
    let instructorData = instructor.toObject();

    // If search query is present
    if (search) {
      const lowercasedSearch = search.toLowerCase().trim();
      
      // Filter subjects and students based on search criteria
      instructorData.load = instructorData.load.map(subject => {
        // Filter students within each subject
        subject.students = subject.students.filter(student => 
          [
            student.last_name,
            student.first_name,
            student.middle_name
          ].some(field => 
            field.toLowerCase().includes(lowercasedSearch)
          )
        );
        // Return the subject with filtered students
        return subject;
      }).filter(subject => subject.students.length > 0); // Remove subjects with no matching students

      // If no subjects have matching students, remove load array
      if (instructorData.load.length === 0) {
        instructorData = { ...instructorData, load: [] };
      }
    }

    res.status(200).json(instructorData);
  } catch (error) {
    console.error('Error fetching Faculty Staff:', error);
    res.status(500).json({
      message: 'Failed to fetch faculty Staff',
      error: error.message
    });
  }
});




const loadSchema = Joi.object({
  _id: Joi.string().required(),
  subject_code: Joi.string().required(),
  subject_title: Joi.string().required(),
  students:Joi.array().default([]),
  course: Joi.string().required(),
  year: Joi.string().required(),
  section: Joi.string().required(),
  semester: Joi.string().required(),
  academic_year: Joi.string().required()
});

const validateInstructorsLoad = (data) => {
  return loadSchema.validate(data, { abortEarly: false }); // Ensure all errors are captured
};

// @desc    Post instructors Load
// @route   POST /api/post_instructors_load
// @access  Private
const postInstructorsLoad = asyncHandler(async (req, res) => {
  console.log('Received data:', req.body);

  // Validate and apply default values
  const { error, value: validatedData } = validateInstructorsLoad(req.body);
  if (error) {
    return res.status(400).json({ message: error.details.map(detail => detail.message).join(', ') });
  }

  const { _id, subject_code, subject_title, students, course, year, section, semester, academic_year } = validatedData;

  try {
    // Find the instructor by _id
    const instructor = await facultyStaffModel.findById(_id); // Changed to findById for consistency
    if (!instructor) {
      return res.status(404).json({ message: "Instructor not found" });
    }

    // Create new load entry
    const newLoad = {
      subject_code,
      subject_title,
      students,
      course,
      year,
      section,
      semester,
      academic_year
    };

    // Add new load to the instructor's load array
    instructor.load.push(newLoad);

    // Save changes to the database
    await instructor.save();

    res.status(200).json({
      message: "Successfully added new Instructor's Load"
    });
  } catch (error) {
    console.error('Error saving Instructor\'s Load:', error);
    res.status(500).json({
      message: "Error saving Instructor's Load",
      error: error.message
    });
  }
});


// @desc    Delete faculty staff
// @route   DELETE /api/del_faculty_staff/:id
// @access  Private 
const deleteFacultyStaff = asyncHandler ( async (req, res) => {
  try {
    const { id } = req.params;
    const result = await facultyStaffModel.findByIdAndDelete(id);

    if (!result) {
      return res.status(404).json({ message: 'Faculty Staff not found' });
    }

    res.status(200).json({ message: 'Faculty Staff deleted successfully' });
  } catch (error) {
    res.status(500).json({ message: 'Server error', error });
  }
});

// @desc    Delete faculty staff
// @route   DELETE /api/del_instructors_load/:id
// @access  Private 
const deleteInstructorsLoad = asyncHandler(async (req, res) => {
  try {
    const { id } = req.params;

    const result = await facultyStaffModel.updateOne(
      { 'load._id': id },
      { $pull: { load: { _id: id } } }
    );

    if (result.modifiedCount === 0) {
      return res.status(404).json({ message: "Instructor's Load not found" });
    }

    res.status(200).json({ message: "Instructor's Load deleted successfully" });
  } catch (error) {
    console.error('Error deleting Instructor\'s Load:', error);
    res.status(500).json({ message: "Error deleting Instructor's Load", error: error.message });
  }
});



// @desc    Post Instructor's Load files
// @route   GET /api/post_instructors_load_upload
// @access  Private

// Set up storage configuration for multer
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/'); // Specify the directory to save uploaded files
  },
  filename: (req, file, cb) => {
    const ext = path.extname(file.originalname);
    cb(null, `${Date.now()}${ext}`); // Append timestamp to filename
  }
});

// Create the multer instance
const upload = multer({ storage });

// Controller function for handling file upload
const postInstructorsLoadFileUpload = asyncHandler(async (req, res) => {
  if (!req.file) {
    return res.status(400).json({ message: "No file uploaded" });
  }

  const { instructorId } = req.body; // Extract instructorId from the form data
  if (!instructorId) {
    return res.status(400).json({ message: "Instructor ID is missing" });
  }

  const filePath = path.resolve(req.file.path);
  const results = [];

  fs.createReadStream(filePath)
    .pipe(csv())
    .on('data', (data) => {
      const { subject_code, subject_title, course, year, section, semester, academic_year } = data;
      results.push({
        subject_code,
        subject_title,
        course,
        year,
        section,
        semester,
        academic_year
      });
    })
    .on('end', async () => {
      try {
        // Find the faculty by the provided instructorId
        const faculty = await facultyStaffModel.findOne({ _id: instructorId });

        if (!faculty) {
          console.error(`Faculty staff with ID ${instructorId} not found.`);
          return res.status(404).json({ message: `Faculty staff with ID ${instructorId} not found.` });
        }

        for (const result of results) {
          // Add new load entry to the faculty's load
          faculty.load.push({
            subject_code: result.subject_code,
            subject_title: result.subject_title,
            course: result.course,
            year: result.year,
            section: result.section,
            semester: result.semester,
            academic_year: result.academic_year
          });
        }

        // Save changes
        await faculty.save();

        res.status(200).json({ message: "File uploaded and data saved successfully" });
      } catch (error) {
        console.error('Error saving data to the database:', error);
        res.status(500).json({ message: "Error saving data to the database", error });
      } finally {
        try {
          fs.unlinkSync(filePath);
        } catch (cleanupError) {
          console.error('Error deleting file:', cleanupError);
        }
      }
    })
    .on('error', (error) => {
      console.error('Error reading CSV file:', error);
      res.status(500).json({ message: "Error reading CSV file", error });
    });
});

// @desc    Add Student
// @route   POST /api/post_instructors_load_student/:facultyId/load/:loadId/add_student
// @access  Private
const addStudentToInstructorsStudents = async (req, res) => {
  try {
    const { facultyId, loadId } = req.params; // Get both faculty and load IDs
    const studentData = req.body; // Assuming student data is sent in the request body

    // Find the faculty member and update the specific load entry
    const updatedInstructor = await facultyStaffModel.findOneAndUpdate(
      {
        _id: facultyId,
        "load._id": loadId // Match the specific load document
      },
      {
        $push: { "load.$.students": studentData } // Use positional operator to push into the correct students array
      },
      { new: true } // Return the updated document
    );

    if (!updatedInstructor) {
      return res.status(404).json({ message: "Instructor or Load not found" });
    }

    res.json(updatedInstructor);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Error adding student' });
  }
};


// @desc    Delete Student from Load
// @route   DELETE /api/post_instructors_load_student/:instructorId/load/:loadId/student/:studentId
// @access  Private
const deleteStudentFromLoad = async (req, res) => {
  try {
    const { instructorId, loadId, studentId } = req.params;

    // Find the instructor by ID and update the load by removing the student
    const updatedInstructor = await facultyStaffModel.findOneAndUpdate(
      { _id: instructorId, 'load._id': loadId },
      { $pull: { 'load.$.students': { _id: studentId } } },
      { new: true }
    );

    if (!updatedInstructor) {
      return res.status(404).json({ message: 'Student or Load not found' });
    }

    res.json(updatedInstructor);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Error deleting student' });
  }
};


const uploadStudentsCSV = async (req, res) => {
  try {
    console.log('Received file upload request'); // Debug statement

    if (!req.file) {
      console.log('No file uploaded'); // Debug statement
      return res.status(400).json({ message: 'No file uploaded' });
    }

    const { instructorId, loadId } = req.params;
    console.log(`Instructor ID: ${instructorId}, Load ID: ${loadId}`); // Debug statement

    if (!instructorId || !loadId) {
      console.log('Instructor ID or Load ID missing'); // Debug statement
      return res.status(400).json({ message: 'Instructor ID and Load ID are required' });
    }

    const students = [];

    fs.createReadStream(req.file.path)
      .pipe(csv())
      .on('data', (row) => {
        console.log('Parsed row:', row); // Debug statement
        students.push({
          schoolID: row.schoolID,
          last_name: row.last_name,
          first_name: row.first_name,
          middle_name: row.middle_name,
        });
      })
      .on('end', async () => {
        try {
          console.log('CSV parsing completed'); // Debug statement
          const faculty = await facultyStaffModel.findOne({ _id: instructorId });
          if (!faculty) {
            console.log('Faculty not found'); // Debug statement
            return res.status(404).json({ message: 'Faculty not found' });
          }

          const load = faculty.load.id(loadId);
          if (!load) {
            console.log('Load not found'); // Debug statement
            return res.status(404).json({ message: 'Load not found' });
          }

          console.log('Load before update:', load); // Debug statement

          load.students.push(...students);

          await faculty.save();

          console.log('Updated faculty:', faculty); // Debug statement

          res.status(201).json({ message: 'Students uploaded successfully', students });
        } catch (error) {
          console.error('Error saving students:', error);
          res.status(500).json({ message: 'Failed to save students', error });
        } finally {
          fs.unlinkSync(req.file.path);
        }
      })
      .on('error', (error) => {
        console.error('Error reading CSV file:', error);
        res.status(500).json({ message: 'Error reading CSV file', error });
      });
  } catch (error) {
    console.error('Failed to upload file:', error);
    res.status(500).json({ message: 'Failed to upload file', error });
  }
};


// @desc    Get Faculty Details by userId
// @route   GET /api/get_faculty_details/:id
// @access  Private
const getFacultyDetails = asyncHandler(async (req, res) => {
  const { id } = req.params;

  // Validate ObjectId format
  if (!mongoose.Types.ObjectId.isValid(id)) {
    return res.status(400).json({ message: 'Invalid userId format' });
  }

  try {
    // Fetch user by id
    const user = await facultyStaffModel.findById(id);

    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    res.status(200).json(user);
  } catch (error) {
    console.error('Error fetching user details:', error);
    res.status(500).json({ message: 'Failed to fetch user details', error: error.message });
  }
});

const convertFinalGradeToEquivalent = (finalGrade) => {
  if (finalGrade >= 95) return 1.0;
  if (finalGrade >= 90) return 1.25;
  if (finalGrade >= 85) return 1.5;
  if (finalGrade >= 80) return 1.75;
  if (finalGrade >= 75) return 2.0;
  if (finalGrade >= 70) return 2.5;
  if (finalGrade >= 65) return 3.0;
  if (finalGrade >= 60) return 3.5;
  return 5.0; // Assuming 5.0 is a failing grade
};

// @desc    Update Student Grades
// @route   PATCH /api/instructors/:instructorId/load/:loadId/student/:studentId/grades
// @access  Private
const updateStudentGrades = asyncHandler(async (req, res) => {
  const { instructorId, loadId, studentId } = req.params;
  const { midtermGrade, finalGrade } = req.body;

  try {
    const instructor = await facultyStaffModel.findById(instructorId);
    if (!instructor) {
      return res.status(404).json({ message: "Instructor not found" });
    }

    const load = instructor.load.id(loadId);
    if (!load) {
      return res.status(404).json({ message: "Load not found" });
    }

    const student = load.students.id(studentId);
    if (!student) {
      return res.status(404).json({ message: "Student not found" });
    }

    student.MIDTERM_GRADE = midtermGrade;
    student.FINAL_GRADE = finalGrade;

    // Calculate and store equivalent grade
    student.EQUIVALENT = convertFinalGradeToEquivalent(finalGrade);

    await instructor.save();

    res.status(200).json({ message: "Student grades updated successfully", student });
  } catch (error) {
    console.error("Error updating student grades:", error);
    res.status(500).json({
      message: "Failed to update student grades",
      error: error.message,
    });
  }
});


// @desc    Post Instructor's Grade Sheet Upload
// @route   POST /api/upload_gradeSheet
// @access  Private

// Helper function to process the file with the worker
const processFileWithWorker = (filePath) => {
  return new Promise((resolve, reject) => {
    const worker = new Worker(path.resolve(__dirname, '../utils/fileProcessorWorker.js'), {
      workerData: { filePath }
    });

    worker.on('message', (result) => {
      resolve(result);
    });

    worker.on('error', (error) => {
      reject(error);
    });

    worker.on('exit', (code) => {
      if (code !== 0) {
        reject(new Error(`Worker stopped with exit code ${code}`));
      }
    });
  });
};

// Controller function to handle grade sheet upload
const uploadGradeSheet = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No file uploaded.' });
    }

    const filePath = req.file.path;

    // Process the file with the worker
    const {
      semester,
      academicYear,
      subjectCode,
      subjectTitle,
      units,
      students
    } = await processFileWithWorker(filePath);

    // Remove the file after processing
    fs.unlinkSync(filePath);

    // Save extracted data to the database
    await Faculty.findOneAndUpdate(
      { _id: req.body.instructorId },
      {
        $push: {
          load: {
            semester,
            academic_year: academicYear,
            subject_code: subjectCode,
            subject_title: subjectTitle,
            units,
            students
          }
        }
      },
      { new: true }
    );

    res.status(200).json({ message: 'Grade sheet uploaded and processed successfully.' });
  } catch (error) {
    console.error('Error saving data to the database:', error);
    res.status(500).json({ error: 'Failed to process and save the grade sheet. Please try again.' });
  }
};





module.exports = {
  postFacultyStaff,
  getFacultyStaff,
  getFacultyToClassProg,
  getInstructorById,
  postInstructorsLoad,
  deleteFacultyStaff,
  deleteInstructorsLoad,
  postInstructorsLoadFileUpload,
  addStudentToInstructorsStudents,
  deleteStudentFromLoad,
  uploadStudentsCSV,
  getFacultyDetails,
  updateStudentGrades,
  uploadGradeSheet
};

